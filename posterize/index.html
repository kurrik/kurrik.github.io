<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Posterize Utility App</title>
  <link rel="stylesheet" href="./bezier-slider.css">
  <style>
    body {
      font-family: system-ui, sans-serif;
      background: #f7f7f7;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    .container {
      margin-top: 32px;
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.07);
      padding: 32px 24px 24px 24px;
      max-width: 540px;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .dropzone {
      border: 2px dashed #bbb;
      border-radius: 8px;
      width: 440px;
      height: 220px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #888;
      background: #fafafa;
      margin-bottom: 18px;
      cursor: pointer;
      transition: border-color 0.2s;
    }
    .dropzone.dragover {
      border-color: #0074d9;
      color: #0074d9;
    }
    canvas {
      margin: 18px 0 12px 0;
      border-radius: 4px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
      background: #eaeaea;
      max-width: 100%;
      width: 440px;
      height: auto;
      display: block;
    }
    .controls {
      width: 100%;
      margin-bottom: 10px;
    }
    .slider-group {
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px 14px;
    }
    label {
      font-size: 15px;
      margin-right: 8px;
      white-space: nowrap;
    }
    input[type="range"] {
      width: 160px;
      min-width: 120px;
      max-width: 220px;
    }
    .thresholds {
      margin-top: 8px;
      width: 100%;
    }
    .threshold-slider {
      display: flex;
      align-items: center;
      margin-bottom: 6px;
    }
    .threshold-slider label {
      min-width: 80px;
    }
    .footer {
      margin-top: 18px;
      font-size: 13px;
      color: #aaa;
      text-align: center;
      width: 100%;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Posterize Image</h2>
    <div id="dropzone" class="dropzone">
      Drag & Drop Image Here<br>or Click to Select
      <input type="file" id="fileInput" accept="image/*" style="display:none">
    </div>
    <canvas id="canvas" width="320" height="180" style="display:none;"></canvas>
    <div class="controls">

      <div class="slider-group">
        <label for="colorCount">Colors:</label>
        <input type="range" id="colorCount" min="2" max="8" value="3">
        <span id="colorCountLabel">3</span>
      </div>
      <div class="thresholds" id="thresholdControls">
        <!-- Threshold sliders will be injected here -->
      </div>
      <div class="slider-group" id="noiseControls">
        <label><input type="checkbox" id="noiseEnable"> Remove Noise</label>
        <label for="noiseThreshold" style="margin-left:12px;">Min Region Size:</label>
        <input type="range" id="noiseThreshold" min="1" max="100" value="8" disabled>
        <span id="noiseThresholdLabel">8</span>
      </div>
      <div class="slider-group" id="smoothControls">
        <label><input type="checkbox" id="smoothEnable"> Smooth Edges</label>
        <label for="smoothStrength" style="margin-left:12px;">Strength:</label>
        <input type="range" id="smoothStrength" min="1" max="10" value="2" disabled>
        <span id="smoothStrengthLabel">2</span>
      </div>
    </div>
    <div style="display:flex;gap:12px;margin:12px 0 0 0;">
      <button id="vectorPreviewBtn">Preview Vector</button>
      <button id="resetBtn">Reset</button>
    </div>
    <div id="vectorPreviewContainer" style="width:100%;margin-top:18px;display:none;flex-direction:column;align-items:center;">
      <div style="margin-bottom:6px;"><b>Vector Preview (SVG):</b></div>
      <div class="slider-group" id="bezierSliderGroup" style="display:none;max-width:340px;width:100%;margin:0 auto 10px auto;">
        <label id="bezierSliderLabel" for="bezierSlider">Curve Fit:</label>
        <input type="range" id="bezierSlider" min="0" max="10" value="3">
        <span id="bezierSliderValue">3</span>
      </div>
      <div id="vectorPreview"></div>
      <a id="downloadSvg" href="#" download="posterized.svg" style="display:block;margin-top:8px;">Download SVG</a>
    </div>
    <div class="footer">Drop an image to begin. Adjust colors and thresholds to posterize.</div>
  </div>
  <script src="./bezier.js"></script>
  <script>
    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const colorCountSlider = document.getElementById('colorCount');
    const colorCountLabel = document.getElementById('colorCountLabel');
    const thresholdControls = document.getElementById('thresholdControls');
    let image = null;
    let colorCount = parseInt(colorCountSlider.value, 10);
    let thresholds = Array.from({length: colorCount-1}, (_,i) => Math.round(255 * (i+1)/colorCount));
    const noiseEnable = document.getElementById('noiseEnable');
    const noiseThreshold = document.getElementById('noiseThreshold');
    const noiseThresholdLabel = document.getElementById('noiseThresholdLabel');
    const smoothEnable = document.getElementById('smoothEnable');
    const smoothStrength = document.getElementById('smoothStrength');
    const smoothStrengthLabel = document.getElementById('smoothStrengthLabel');
    const vectorPreviewBtn = document.getElementById('vectorPreviewBtn');
    const resetBtn = document.getElementById('resetBtn');
    const vectorPreviewContainer = document.getElementById('vectorPreviewContainer');
    const vectorPreview = document.getElementById('vectorPreview');
    const downloadSvg = document.getElementById('downloadSvg');

    // --- Local Storage Keys ---
    const STORAGE_KEY = 'posterizeAppState';

    // --- Drag and Drop Logic ---
    dropzone.addEventListener('click', () => fileInput.click());

    // --- Reset Button ---
    resetBtn.addEventListener('click', () => {
      localStorage.removeItem(STORAGE_KEY);
      image = null;
      colorCountSlider.value = 3;
      colorCountLabel.innerText = 3;
      colorCount = 3;
      thresholds = [85, 170];
      renderThresholdControls();
      noiseEnable.checked = false;
      noiseThreshold.value = 8;
      noiseThresholdLabel.innerText = 8;
      noiseThreshold.disabled = true;
      smoothEnable.checked = false;
      smoothStrength.value = 2;
      smoothStrengthLabel.innerText = 2;
      smoothStrength.disabled = true;
      canvas.style.display = 'none';
      vectorPreviewContainer.style.display = 'none';
      fileInput.value = '';
      posterize();
    });
    dropzone.addEventListener('dragover', e => {
      e.preventDefault();
      dropzone.classList.add('dragover');
    });
    dropzone.addEventListener('dragleave', () => dropzone.classList.remove('dragover'));
    dropzone.addEventListener('drop', e => {
      e.preventDefault();
      dropzone.classList.remove('dragover');
      if (e.dataTransfer.files && e.dataTransfer.files[0]) {
        loadImage(e.dataTransfer.files[0]);
      }
    });
    fileInput.addEventListener('change', e => {
      if (fileInput.files && fileInput.files[0]) {
        loadImage(fileInput.files[0]);
      }
    });

    function loadImage(file, optionalDataUrl) {
      function onloadHandler(dataUrl) {
        const img = new window.Image();
        img.onload = function() {
          // Resize canvas to fit image, max 320x320
          const maxDim = 320;
          let w = img.width, h = img.height;
          if (w > maxDim || h > maxDim) {
            const scale = Math.min(maxDim/w, maxDim/h);
            w = Math.round(w * scale);
            h = Math.round(h * scale);
          }
          canvas.width = w;
          canvas.height = h;
          ctx.drawImage(img, 0, 0, w, h);
          image = ctx.getImageData(0, 0, w, h);
          canvas.style.display = '';
          // Save the original image data URL to window for persistence
          if (!optionalDataUrl) {
            window._originalImageDataUrl = canvas.toDataURL();
          } else if (!window._originalImageDataUrl) {
            window._originalImageDataUrl = optionalDataUrl;
          }
          saveState();
          posterize();
        };
        img.src = dataUrl;
      }
      if (optionalDataUrl) {
        onloadHandler(optionalDataUrl);
      } else {
        const reader = new FileReader();
        reader.onload = function(evt) {
          onloadHandler(evt.target.result);
        };
        reader.readAsDataURL(file);
      }
    }

    // --- Posterization Logic ---
    function posterize() {
      if (!image) return;
      const w = image.width, h = image.height;
      // Step 1: Assign buckets
      const buckets = new Uint8Array(w * h);
      const data = image.data;
      for (let y = 0; y < h; ++y) {
        for (let x = 0; x < w; ++x) {
          const i = (y * w + x) * 4;
          const lum = 0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2];
          let bucket = 0;
          while (bucket < thresholds.length && lum > thresholds[bucket]) bucket++;
          buckets[y * w + x] = bucket;
        }
      }
      // Step 2: Optionally remove noise
      if (noiseEnable.checked) {
        removeNoise(buckets, w, h, parseInt(noiseThreshold.value, 10));
      }
      // Step 3: Optionally smooth
      if (smoothEnable.checked) {
        smoothBuckets(buckets, w, h, colorCount, parseInt(smoothStrength.value, 10));
      }
      // Step 4: Write to output image
      const imgData = ctx.createImageData(w, h);
      const out = imgData.data;
      for (let y = 0; y < h; ++y) {
        for (let x = 0; x < w; ++x) {
          const bucket = buckets[y * w + x];
          const v = Math.round(255 * (bucket/(colorCount-1)));
          const i = (y * w + x) * 4;
          out[i] = out[i+1] = out[i+2] = v;
          out[i+3] = data[i+3];
        }
      }
      ctx.putImageData(imgData, 0, 0);
      saveState();
    }

    // --- Smoothing ---
    function smoothBuckets(buckets, w, h, colorCount, iterations) {
      const dx = [-1, 0, 1, -1, 1, -1, 0, 1];
      const dy = [-1,-1,-1, 0, 0, 1, 1, 1];
      let src = buckets, dst = new Uint8Array(w * h);
      for (let it = 0; it < iterations; ++it) {
        for (let y = 0; y < h; ++y) {
          for (let x = 0; x < w; ++x) {
            const idx = y * w + x;
            const counts = new Array(colorCount).fill(0);
            for (let d = 0; d < 8; ++d) {
              const nx = x + dx[d], ny = y + dy[d];
              if (nx < 0 || ny < 0 || nx >= w || ny >= h) continue;
              counts[src[ny * w + nx]]++;
            }
            // Majority vote (ties prefer current value)
            let maxBucket = src[idx], maxCount = counts[src[idx]];
            for (let i = 0; i < counts.length; ++i) {
              if (counts[i] > maxCount) {
                maxCount = counts[i];
                maxBucket = i;
              }
            }
            dst[idx] = maxBucket;
          }
        }
        // Swap src/dst
        let tmp = src; src = dst; dst = tmp;
      }
      // Copy back if needed
      if (src !== buckets) {
        for (let i = 0; i < w * h; ++i) buckets[i] = src[i];
      }
    }

    // --- Noise Removal ---
    // Remove regions smaller than minSize (4-way connected)
    function removeNoise(buckets, w, h, minSize) {
      const visited = new Uint8Array(w * h);
      const dx = [1, -1, 0, 0], dy = [0, 0, 1, -1];
      for (let y = 0; y < h; ++y) {
        for (let x = 0; x < w; ++x) {
          const idx = y * w + x;
          if (visited[idx]) continue;
          const region = [], queue = [[x, y]];
          const origBucket = buckets[idx];
          visited[idx] = 1;
          region.push(idx);
          // BFS to find region
          while (queue.length) {
            const [cx, cy] = queue.pop();
            for (let d = 0; d < 4; ++d) {
              const nx = cx + dx[d], ny = cy + dy[d];
              if (nx < 0 || ny < 0 || nx >= w || ny >= h) continue;
              const nidx = ny * w + nx;
              if (!visited[nidx] && buckets[nidx] === origBucket) {
                visited[nidx] = 1;
                queue.push([nx, ny]);
                region.push(nidx);
              }
            }
          }
          if (region.length < minSize) {
            // Assign to majority neighbor bucket
            const counts = new Array(colorCount).fill(0);
            for (const ridx of region) {
              const rx = ridx % w, ry = Math.floor(ridx / w);
              for (let d = 0; d < 4; ++d) {
                const nx = rx + dx[d], ny = ry + dy[d];
                if (nx < 0 || ny < 0 || nx >= w || ny >= h) continue;
                const nidx = ny * w + nx;
                if (buckets[nidx] !== origBucket) {
                  counts[buckets[nidx]]++;
                }
              }
            }
            let maxBucket = origBucket, maxCount = -1;
            for (let i = 0; i < counts.length; ++i) {
              if (counts[i] > maxCount) {
                maxCount = counts[i];
                maxBucket = i;
              }
            }
            for (const ridx of region) {
              buckets[ridx] = maxBucket;
            }
          }
        }
      }
    }

    // --- Threshold Controls ---
    function renderThresholdControls() {
      thresholdControls.innerHTML = '';
      for (let i = 0; i < colorCount-1; ++i) {
        const group = document.createElement('div');
        group.className = 'threshold-slider';
        const label = document.createElement('label');
        label.innerText = `Threshold ${i+1}`;
        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = 0; slider.max = 255;
        slider.value = parseInt(thresholds[i], 10);
        slider.step = 1;
        slider.min = 0;
        slider.max = 255;
        const value = document.createElement('span');
        value.innerText = slider.value;
        slider.addEventListener('input', () => {
          const v = parseInt(slider.value, 10);
          thresholds[i] = v;
          value.innerText = v;
          saveState();
          posterize();
        });
        group.appendChild(label);
        group.appendChild(slider);
        group.appendChild(value);
        thresholdControls.appendChild(group);
      }
    }

    // --- Color Count Control ---
    colorCountSlider.addEventListener('input', () => {
      colorCount = parseInt(colorCountSlider.value, 10);
      colorCountLabel.innerText = colorCount;
      // Evenly space thresholds
      thresholds = Array.from({length: colorCount-1}, (_,i) => Math.round(255 * (i+1)/colorCount));
      renderThresholdControls(); // Only re-render controls when color count changes
      saveState();
      posterize();
    });

    // --- Noise Controls ---
    noiseEnable.addEventListener('change', () => {
      noiseThreshold.disabled = !noiseEnable.checked;
      saveState();
      posterize();
    });
    noiseThreshold.addEventListener('input', () => {
      noiseThresholdLabel.innerText = noiseThreshold.value;
      saveState();
      if (noiseEnable.checked) posterize();
    });

    // --- Smoothing Controls ---
    smoothEnable.addEventListener('change', () => {
      smoothStrength.disabled = !smoothEnable.checked;
      saveState();
      posterize();
    });
    smoothStrength.addEventListener('input', () => {
      smoothStrengthLabel.innerText = smoothStrength.value;
      saveState();
      if (smoothEnable.checked) posterize();
    });

    // --- Vector Preview ---
    vectorPreviewBtn.addEventListener('click', () => {
      if (!image) return;
      // Recompute buckets as in posterize()
      const w = image.width, h = image.height;
      const buckets = new Uint8Array(w * h);
      const data = image.data;
      for (let y = 0; y < h; ++y) {
        for (let x = 0; x < w; ++x) {
          const i = (y * w + x) * 4;
          const lum = 0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2];
          let bucket = 0;
          while (bucket < thresholds.length && lum > thresholds[bucket]) bucket++;
          buckets[y * w + x] = bucket;
        }
      }
      if (noiseEnable.checked) {
        removeNoise(buckets, w, h, parseInt(noiseThreshold.value, 10));
      }
      if (smoothEnable.checked) {
        smoothBuckets(buckets, w, h, colorCount, parseInt(smoothStrength.value, 10));
      }
      // --- Bezier slider only appears after preview ---
      const bezierSliderGroup = document.getElementById('bezierSliderGroup');
      const bezierSlider = document.getElementById('bezierSlider');
      const bezierSliderValue = document.getElementById('bezierSliderValue');
      bezierSliderGroup.style.display = '';
      bezierSliderValue.textContent = bezierSlider.value;
      // Helper to update preview
      function renderBezierPreview(tolerance) {
        const colors = Array.from({length: colorCount}, (_,i) => `rgb(${Math.round(255*i/(colorCount-1))},${Math.round(255*i/(colorCount-1))},${Math.round(255*i/(colorCount-1))})`);
        vectorPreview.innerHTML = '';
        downloadSvg.style.display = 'none';
        vectorPreviewContainer.style.display = 'flex';
        let allSvgs = [];
        let downloadAllBtn = document.createElement('button');
        downloadAllBtn.textContent = 'Download All';
        downloadAllBtn.style.margin = '0 auto 18px auto';
        downloadAllBtn.style.display = 'block';
        downloadAllBtn.style.padding = '8px 18px';
        downloadAllBtn.style.fontSize = '15px';
        downloadAllBtn.style.borderRadius = '6px';
        downloadAllBtn.style.background = '#222';
        downloadAllBtn.style.color = 'white';
        downloadAllBtn.style.boxShadow = '0 2px 8px rgba(0,0,0,0.09)';
        downloadAllBtn.style.cursor = 'pointer';
        downloadAllBtn.onclick = function() {
          if (allSvgs.length === 0) return;
          if (typeof JSZip === 'undefined') {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
            script.onload = () => downloadAllBtn.onclick();
            document.body.appendChild(script);
            return;
          }
          const zip = new JSZip();
          allSvgs.forEach(({svg, name}) => zip.file(name, svg));
          zip.generateAsync({type:'blob'}).then(blob => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'posterized_svgs.zip';
            document.body.appendChild(a);
            a.click();
            setTimeout(()=>{
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
            }, 100);
          });
        };
        vectorPreview.appendChild(downloadAllBtn);
        // --- Stacked Preview Container ---
        const stackContainer = document.createElement('div');
        stackContainer.style.position = 'relative';
        stackContainer.style.display = 'block';
        stackContainer.style.background = '#ff00cc';
        stackContainer.style.borderRadius = '12px';
        stackContainer.style.padding = '12px';
        stackContainer.style.margin = '0 auto 18px auto';
        stackContainer.style.width = w + 'px';
        stackContainer.style.height = h + 'px';
        stackContainer.style.minWidth = w + 'px';
        stackContainer.style.minHeight = h + 'px';
        stackContainer.style.overflow = 'auto';
        stackContainer.style.boxShadow = '0 4px 24px rgba(0,0,0,0.10)';
        stackContainer.style.textAlign = 'center';
        stackContainer.style.backgroundClip = 'padding-box';
        // Add a white background behind the SVGs for clarity
        const whiteBg = document.createElement('div');
        whiteBg.style.position = 'absolute';
        whiteBg.style.left = '0';
        whiteBg.style.top = '0';
        whiteBg.style.width = '100%';
        whiteBg.style.height = '100%';
        whiteBg.style.background = 'white';
        whiteBg.style.opacity = '0.96';
        whiteBg.style.borderRadius = '8px';
        whiteBg.style.zIndex = '0';
        stackContainer.appendChild(whiteBg);
        vectorPreview.appendChild(stackContainer);
        stackContainer.insertBefore(whiteBg, stackContainer.firstChild);
        // For each color bucket, create a mask and fit bezier curves
        for (let bucket = 0; bucket < colorCount; ++bucket) {
          // Build mask for this bucket
          const mask = new Uint8Array(w * h);
          for (let i = 0; i < w * h; ++i) mask[i] = buckets[i] === bucket ? 1 : 0;
          // Find contours
          const contours = window.findContours(mask, w, h);
          // Fit bezier curves and build SVG paths
          let paths = '';
          for (const contour of contours) {
            const d = window.fitBezierCurve(contour, parseFloat(tolerance));
            if (d && d.length > 2) {
              paths += `<path d="${d}" fill="${colors[bucket]}" stroke="#222" stroke-width="0.5"/>`;
            }
          }
          const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">${paths}</svg>`;
          // Add to preview
          const svgWrapper = document.createElement('div');
          svgWrapper.style.position = 'absolute';
          svgWrapper.style.left = '0';
          svgWrapper.style.top = '0';
          svgWrapper.style.width = w + 'px';
          svgWrapper.style.height = h + 'px';
          svgWrapper.style.pointerEvents = 'none';
          svgWrapper.style.zIndex = (bucket + 1).toString();
          svgWrapper.innerHTML = svg;
          stackContainer.appendChild(svgWrapper);
          allSvgs.push({svg, name: `color${bucket+1}.svg`});
        }
      }
      // Initial render with current slider value
      renderBezierPreview(bezierSlider.value);
      // Live update on slider
      bezierSlider.oninput = function() {
        bezierSliderValue.textContent = bezierSlider.value;
        renderBezierPreview(bezierSlider.value);
      };
    });
    // Always update label when slider changes (even outside preview)
    bezierSlider.addEventListener('input', function() {
      bezierSliderValue.textContent = bezierSlider.value;
    });
    // Hide the bezier slider group on reset
    resetBtn.addEventListener('click', () => {
      document.getElementById('bezierSliderGroup').style.display = 'none';
    });

    // --- Save/Load State ---
    function saveState() {
      try {
        const state = {
          colorCount,
          thresholds,
          noiseEnable: noiseEnable.checked,
          noiseThreshold: noiseThreshold.value,
          smoothEnable: smoothEnable.checked,
          smoothStrength: smoothStrength.value,
          originalImageDataUrl: null
        };
        // Save original image if present
        if (window._originalImageDataUrl) {
          state.originalImageDataUrl = window._originalImageDataUrl;
        }
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch (e) {}
    }

    function loadState() {
      try {
        const state = JSON.parse(localStorage.getItem(STORAGE_KEY));
        if (!state) return;
        colorCount = parseInt(state.colorCount, 10);
        colorCountSlider.value = String(colorCount);
        colorCountLabel.innerText = String(colorCount);
        thresholds = Array.isArray(state.thresholds) ? state.thresholds.map(v => parseInt(v, 10)) : [85,170];
        renderThresholdControls();
        noiseEnable.checked = !!state.noiseEnable;
        noiseThreshold.value = String(parseInt(state.noiseThreshold, 10));
        noiseThresholdLabel.innerText = String(noiseThreshold.value);
        noiseThreshold.disabled = !noiseEnable.checked;
        smoothEnable.checked = !!state.smoothEnable;
        smoothStrength.value = String(parseInt(state.smoothStrength, 10));
        smoothStrengthLabel.innerText = String(smoothStrength.value);
        smoothStrength.disabled = !smoothEnable.checked;
        if (state.originalImageDataUrl) {
          loadImage(null, state.originalImageDataUrl);
        }
      } catch (e) {}
    }

    // Initial render
    renderThresholdControls();
    loadState();
  </script>
</body>
</html>
